## Java Question List

###1. 面向对象的三个基本元素和五个原则

   1. 三个基本元素：

   - 封装：从字面上理解就是包装的意思，是指利用抽象数据类型，将数据和关于数据的操作封装起来，使其成为一个不可分割的独立实体。数据将会被保护在抽象数据类型的内部，仅能够通过暴露在表面的操作（public方法，比如setter和getter）来与这个对象进行交流和交互。用户不知道对象的内部细节，但是通过该对象提供的接口来访问对象。其好处是：减少耦合，方便地在未来修改调整自己，更加有把握地（精确地）控制成员，隐藏信息，实现细节。

   - 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。

   - 多态： 多态性是指允许不同类的对象对同一消息作出 响应。使用相同的消息，使得类作出不同的反应（继承为我们使用多态打下了基础）。Java实现多态有三个必要条件：继承、重写、向上转型。


   2. 五个基本原则（SOLID）：

   * 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
   * 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。
   * Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。
   * 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
   * 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。

###2. 抽象类和接口的区别？[Link](https://arjun-sna.github.io/java/2017/02/02/abstractvsinterface/)

   - 从Java语言角度讲，interface只允许有一个默认方法（Java8），抽象类可以有实现方法。
   - 在设计层级理解他们的不同：

   1. 抽象的层次不同：抽象类对类的整体（包括属性，行为）都可以进行抽象，接口对类的局部进行抽象，具体来说接口仅仅是对类的行为进行抽象。
   2. 跨域不同：抽象类是 从各种子类中提取相似的部分，然后泛化成抽象类，子类可以继承这样的抽象类。 实现接口是 不存在`is-a`的关系的类们，你不可以称同样可以飞行的飞机和鸟为同一个抽象类，但是他们可以有同样的接口`fly-able`。抽象类的父类和派生类在概念上一致，接口的原生类和派生类在仅仅在局部行为上一致。
   3. 设计层次不同：抽象类是从一堆在底层的子类们来进行抽象提取，从下往上，从而产生抽象类；接口是在直接定义的高度来声明的，然后从这个高度上往下实现此接口。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

###3.序列化是什么?如何实现它?

序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。Java中，有两种方式可以实现序列化，既可以实现Serializable接口，也可以实现Parcelable接口。然而，在Android中，我们不应该使用Serializable接口。因为Serializable接口使用了反射机制，这个过程相对缓慢，而且往往会产生出很多临时对象，这样可能会触发垃圾回收器频繁地进行垃圾回收。相比而言，Parcelable接口比Serializable接口效率更高，性能方面要高出10x多倍。

### 4.对字符串进行 `==` 和 `equals()` 操作时有什么区别？

`==` 比较两个字符串的地址，初学者很经常拿来比较其内容，将会导致出现不等的情况。 `equals()`是String这个类重写的一个方法，平常的类的`equals()`也仅仅是比较两个变量的地址，而String类的`equals()`重写后，将依次比较其串中的字符。

### 5.`hashCode()` 和 `equals()` 何时使用？

一般是在想要人性化地（而不是计算机式地,比较地址那样）比较两个对象的时候，我们需要使用这两个方法，或者说我们要重写这两个方法，而且有如下的原则：

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

### 6.什么是内存泄露，Java 是如何处理它的？

   总的来说是：保留下来却永远不再使用的对象引用    它包括： 1. 静态集合类引起内存泄漏， 2. 当集合里面的对象属性被修改后，再调用remove()方法时不起作用， 3. 监听器， 4. 各种连接 5. 内部类和外部模块的引用 6. 单例模式    详情可见：<http://note.youdao.com/noteshare?id=376631d4640128dc55646c8e577cc3ab>

### 7.比较 `HashSet` 和 `TreeSet`。

   TreeSet是基于二叉树实现的，其中的数据是自动排序好的。不允许放入null值。

   HashSet是基于Hash表实现的，其中的数据是无序的，允许放入null值。

   详细的笔记在：<http://note.youdao.com/noteshare?id=4a3e44e90105d9906eb308317bc816bb>

 