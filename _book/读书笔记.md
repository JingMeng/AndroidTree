## Android开发艺术探索 读书笔记

>这本书在手中已经将近两年的时间，之前一直把它当作工具书，有问题的时候查阅一下，最近要准备面试，把书重新找出来，从头开始，把知识点再梳理一遍，温故知新。

### Activity 的基础知识

1. Activity复用时，回调onNewIntent
2. Activity异常销毁时回调onSaveInstanceState，重建时回调onRestoreInstanceState，可以在onRestoreInstanceState或者onCreate的重载方法中获取销毁前保存的信息

### IPC通信机制

1. Android进程间通信（IPC）的实现方式：Bundle，文件共享，AIDL，Messenger，ContentProvider，Socket，BroadCastReceiver
2. Android进程间通信（IPC）的机制：Binder Parcelable（此处不在叙述Serializable）Parcelable接口在完成数据的序列化过程之后，通过Binder进行传输。实质上Parcelable包含序列化和反序列化

* 那么问题还是来了，为啥需要多进程？如何实现多进程？

  * 为啥要多进程？

    1. Android对单个应用所使用的最大内存做了限制。
    2. 在不同的应用之间共享数 据。
* 如何实现多进程？Manifest清单文件中声明process属性
* WebView开发的时候为啥一般会指定独立进程？ 
  * WebView导致的OOM问题
  * Android版本不同，采用了不同的内核，兼容性Crash
  * WebView代码质量，WebView和Native版本不一致，导致Crash
* 最近两年的开发没有使用到AIDL和Binder，知识点记住，面试要能答上来，具体细节可以在使用的时候查询。  

### Android View体系

1. View的工作原理
   1. onDraw主体绘制

2. 事件分发机制

   1. 关于事件分发机制，可以从两个角度讲解，其一是事件分发的原理和流程

   其实质上，是从Activity向下逐层递归调用dispatchTouchEvent()方法，dispatchTouchEvent()本身是一个调度方法，其内部调用onInterceptTouchEvent，判断当前View是否要拦截该事件，如果不拦截，接着调用onTouchEvent，将事件向下分发，直到有子View返回true，消费该事件。

   其中，onTouchEvent中，如果子View在该事件的action.DOWN事件返回了false，那么本次触摸以后的事件子View都不会收到

   1. 其二是处理事件冲突的具体思路

   具体思路有三个：

   1. 实现自定义触摸反馈，直接在onTouchEvent中处理事件就OK
   2. 父View想要事件，直接在onInterceptTouchEvent中返回true进行拦截。此时，父View对给子View分发一个action.CANCEL的事件，通知子View恢复状态。
   3. 子View不想要父View拦截，调用requestDisallowInterceptTouchEvent()方法，请求父View不要拦截，该方法只对本地事件有效。

   

3. 动画（主要是属性动画）这块的内容从hencoder网站及笔记复习

4. 自定义View/ViewGroup实现
   1. 自定义View已经基本掌握（精通），自定义ViewGroup的关键在于精通onMeasure中关于测量的方法和MeasureSpec的三种不同的模式，onLayout只是简单地把子View布置到该放置的地方，因此onMeasure是自定义ViewGroup的精髓所在。
   2. 要精准地理解View绘制的流程/方法/概念。

### 开源框架

1. OKHttp 责任链模式
2. Glide 图片加载的三级缓存机制
3. RxJava

### Kotlin